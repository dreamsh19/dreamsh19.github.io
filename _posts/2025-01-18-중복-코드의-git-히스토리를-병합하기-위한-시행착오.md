---
categories:
  - Git
tags:
  - Git
published: true
created: 2025-01-18 (토) 20:31:57
modified: 2025-01-19 (일) 23:54:56
---

## 이슈
- 신규 API 코드와 기존 API 코드를 동시에 서비스하던 중, 기존 API를 deprecate시키고, 기존 API 코드를 삭제하려고 하는 상황이었다.
- 그런데 문제는 신규 코드 최초 작성 당시, 기존 코드를 복붙하여 작성되었고, 수년 간의 git 히스토리는 기존 코드에만 남아있고, 신규 코드의 git 히스토리는 복붙 이후의 시점만 기록되어 있었다.
- 아래는 기존 코드에는 히스토리가 다 남아있는 반면, 신규 코드에는 복붙 히스토리만 남아있는 모습이다.
	- (그리고 여기서의 중요한 포인트는 신규 코드는 기존 코드와 90% 이상 일치하는 중복 코드였기 때문에, 신규 코드는 사실상 동일한 코드에서 git 히스토리만 사라진 코드라고 볼 수 있었다.)

|                                            기존                                             |                                            신규                                             |
| :---------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------: |
| ![Image](https://github.com/user-attachments/assets/904ae9a7-e095-4cb4-9d57-8c7839fa3e00) | ![Image](https://github.com/user-attachments/assets/af877689-0eeb-40cf-a949-1d053601bfdf) |

- 여기서 이슈가 발생하는데, 기존 API 코드를 삭제하더라도, git 히스토리는 유지하고자 했다.
	- 개인적으로 각종 히스토리를 파악하는데 git 히스토리를 자주 활용하기도 하고,
	- 단순 히스토리 파악을 포함해서, 미처 몰랐던 선대(?) 개발자들의 의도를 알 수 있어서 같은 실수를 반복하지 않게 하기도 하기 때문이다.
	- 기존 코드를 삭제해도 히스토리를 보려면 볼수야 있지만, 기존 코드 삭제 이후에는 삭제된 기존 코드가 어떤 것이었는지 알아내서 찾아가야 한다.
- 그리고 결정적으로 해당 클래스가 비지니스의 대부분의 주요한 로직을 담고 있는 클래스였다..
- 그래서 아래와 같은 목표를 달성하기 위한 시행착오를 이 글에서 다루었다.

## 목표

기존 코드의 git 히스토리를 신규 코드의 git 히스토리와 병합하고, 기존 코드를 삭제한다.

## 1. Git blame 병합

사실 최초의 목적은 글의 서두에서 보여준 기존 코드의 git blame을 신규 코드의 git blame에 반영하고 싶었던 것이었다.
그리고 정확히 동일한 니즈에 대한 해결책을 다룬 [글](https://devblogs.microsoft.com/oldnewthing/20190514-00/?p=102493)이 있었다!
요지는 rename-rename merge conflict를 이용하는 방법으로,
- 요약하면, 서로 다른 파일 A,B의 git blame을 합치고자 할때, 아래와 같이 수행한다.
	1. branch 1 : A->C rename
	2. branch 2 : B->C rename
	3. branch1과 branch2를 merge
		- 이때 merge conflict를 resolve 해주어야한다.
- 구체적인 방법은 글에서 자세하게 다루고 있으니, 그대로 따라하면 된다.

참고로, 이때 기존 코드를 신규 코드로 바로 merge하지 않는 이유는, 이렇게 하게 되면, git blame 히스토리가 merge 시점으로 모두 덮어써져 버리기 때문에, 달성하고자 하는 목적에 벗어난다.


결과물

![Image](https://github.com/user-attachments/assets/2fc8e7a4-e6e7-489c-be63-b92895e6b75e)

git blame 히스토리가 잘 병합되었다.

### 추가적인 주의사항

아래는 위의 글에 따라 반영하면서 추가적으로 직접 겪었던 시행착오와 그에 따른 주의사항을 기록하였다.

- merge conflict 해소시에는 기존 파일들의 라인을 선택/제거만 하고, 수정이 필요하다면 이후의 별도 커밋에서 수행하는 것이 git blame 유지에 바람직하다.
	- merge conflict 해소 시 기존에 있던 라인을 수정하면, git에서는 merge 시점에 새로운 라인을 추가한 것으로 인식하고, 해당 라인에 대한 히스토리도 merge 커밋 시점으로 기록된다.
	- (git 입장에서는 기존 라인을 수정한 것인지 새로운 라인을 추가한 것인지 자체를 구분하는 것이 불가능하기 때문에)
	- 그래서 merge conflict 해소 직후 시점에는 컴파일이 되지 않는 상태의 커밋이 불가피하게 존재할 수 있다.(수정이 불가능하므로)
- 완전히 동일한 라인이 두 개의 파일에 모두 포함되어 있을때, 해당 라인 히스토리를 어떤 파일의 것으로 따라갈지는 git 자체적인 휴리스틱(해당 라인의 앞뒤 라인의 유사도 등)에 따라 결정되기 때문에 일관된 방법을 찾는 것은 한계가 있다. (따라서 위 글의 예시에서처럼 기계적인 merge conflict resolve는 현실적으로 어렵다. )
- rename 시에는 Intellij 등의 IDE 환경에서 rename하는 경우 파일 내용을 자동으로 바꿔주기 때문에(import나 클래스명 등) cli에서 단순 mv만 실행하는 것을 권장한다.

## 2. Github의 파일 히스토리 통합

위에서 git blame을 합쳤으니 목적을 달성하고 마무리하려고 했다. 그러나 예상치 못한 이슈가 발생했다.
Github에서 파일 히스토리를 확인해보니, rename 이전의 히스토리가 신규 코드 쪽 히스토리만 남아있고, 기존 코드의 히스토리만 남아있던 것이다.

![Image](https://github.com/user-attachments/assets/ca4d5223-d915-4aac-9d92-20779bd58e8e)
(Github UI 상에서 기존 파일에 대한 히스토리 추적이 불가능했다.)

git blame 히스토리만큼이나, 파일 히스토리 또한 중요하므로 보존하기 위한 방법을 찾기 시작했다.

### git log --follow 옵션 버그

Github에서는 특정 파일에 대한 commit 리스트를 아래와 같이 제공한다. (이하 파일 히스토리)

![171795153-4f327a04-eb27-4d46-acb1-73d2e82ce4c5.gif](https://i0.wp.com/user-images.githubusercontent.com/4021812/171795153-4f327a04-eb27-4d46-acb1-73d2e82ce4c5.gif?ssl=1)

그리고 git에서는 파일 히스토리 조회를 목적으로 `git log ${filename}` 형태의 명령어를 제공한다.
참고로 git에는 단순히 커밋의 그래프만을 관리하고 추적하기 때문에 "파일" 단위의 히스토리라는 개념 자체가 없다. 그렇기 때문에 위 git log 명령어는 결국엔 커밋 그래프를 순차적으로 탐색하면서 해당 파일 이름이 포함된 커밋만을 필터링해서 출력해주는 방식으로 동작한다.
여기서 문제가 발생하는데, 필터의 기준이 되는 "파일명"이 달라지는 rename 커밋이 발생한 경우 혼동의 여지가 발생한다.
실제로 `git log ${filename}` 명령어를 수행해보면, rename 커밋 이전의 커밋들은 출력해주지 않는다.

그래서 이러한 한계점을 보완하기 위한 옵션으로 `git log --follow` 옵션을 통해 rename 이전의 히스토리도 추적할 수 있는 기능을 제공한다.
그리고 Github에서도 원래 파일의 rename 히스토리를 지원하지 않았으나, 2022년 업데이트로 rename 이전의 파일 히스토리도 조회할 수 있도록 업데이트되었다.

![Image](https://github.com/user-attachments/assets/32a9cd30-7652-4936-8c3f-28342510df59)
- [https://github.blog/changelog/2022-06-06-view-commit-history-across-file-renames-and-moves/](https://github.blog/changelog/2022-06-06-view-commit-history-across-file-renames-and-moves/)

그런데 위 changelog에서 주목할 점은 `git log --follow`와 "similar"한 방식으로 동작한다는 문구이다.
결국 `git log --follow` 수행결과와 동일하지 않다는 것인데, 실제로 수행결과가 달랐다.

왜 이미 동일한 목적으로 존재하는 `git log --follow` 명령어를 그대로 사용하지 않을까?
그 이유는 `git log --follow` 옵션은 버그가 있는 형태로 현재도 유지되고 있고, 그렇기 때문에 사용자 기대와 다른 결과를 출력하는 경우가 있다.

아래 두 개 링크 [1](https://stackoverflow.com/questions/46487476/git-log-follow-graph-skips-commits/46492159#46492159), [2](https://stackoverflow.com/questions/64454637/git-log-follow-not-working-to-show-history-beyond-renames/64468571#64468571) 에 `git log --follow` 의 내부 동작 방식 및 문제가 되는 케이스를 상세히 다루고 있다.
![Image](https://github.com/user-attachments/assets/a5ad4c8e-c9c6-4649-9cfd-ddac7232bbab)

![Image](https://github.com/user-attachments/assets/fd8ad87a-652f-410b-8c1b-b093cc7dbd54)

결국 요약하면, **parent branch가 여러개 있고, 한쪽 parent에서(혹은 양쪽 모두에서) rename이 있었던 경우 다른 한쪽 parent의 커밋 히스토리는 누락된다** 는 것이다.
해당 파트의 도입부에 첨부했던 캡쳐에서 신규 코드의 파일 히스토리만 조회가 가능했던 것도, 다른 한쪽 브랜치의 기존 코드 커밋 히스토리가 누락되었기 때문이다.

그럼 결국 현재 한계상 한쪽의 코드 커밋 히스토리만 채택해야한다. 그리고 하나를 채택해야한다면, 과거 기록이 훨씬 많이 남아있는 기존 코드일 것이다.
그럼 기존 코드를 의도적으로 남기기 위해선 어떻게 해야할까?

위에서 나온 `git log --follow` 내부 동작을 봤을 때 결국 어떤 쪽이 누락될지는 `git log`의 탐색 순서에 달려있다.
그리고 git log의 탐색 순서는 여러가지 옵션의 형태로 제공하지만 디폴트는 commit 시간의 역순이다.
**따라서, 보존하고자 하는 parent의 rename 커밋이 시간순으로 먼저 발생해야, git log 입장에서 나중에 탐색하게 되어, rename 시에도 해당 히스토리를 따라가게 된다**

위의 경우에는 기존 코드의 히스토리를 보존하고 싶은 케이스이므로, 기존 코드의 rename 커밋을 시간순으로 먼저 수행함으로써 기존 코드의 커밋 히스토리를 보존하는 형태로 수행했다.

## 3. Fast forward merge

여기까지 왔으면, 복잡한 과정을 대부분 지나왔다.
여기서 한 가지 더 추가적인 주의사항이 존재하는데, 이 유의사항을 놓치면 지금까지 한 수고가 무용지물이 될 수 있다. 그것은 바로 merge 방식이다.

대부분의 피쳐 개발과 마찬가지로, 위의 모든 과정을 feature 브랜치에서 진행했기 때문에, develop 및 master로의 머지가 필요하다.
이때, 명시적인 merge commit이 발생하는 경우 master 및 develop 입장에서는 커밋 원자성이 훼손되기 때문에 커밋 원자성을 보존하기 위한 위의 노력들이 모두 물거품이 된다.
따라서, 명시적인 merge commit이 발생하지 않으면서 커밋 원자성을 보존할 수 있는 Fast forward merge 방식을 채택해야한다.

|                                  Non fast forward merge                                   |                                    Fast forward merge                                     |
| :---------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------: |
| ![Image](https://github.com/user-attachments/assets/296705c1-8fae-4de4-ae93-5ad79c1bed7e) | ![Image](https://github.com/user-attachments/assets/b4469f8b-cd20-47e1-9c2a-d61a0a9e5c74) |

(Non-Fast-forward merge와 Fast forward merge의 차이점. 출처 : [🌳🚀 CS Visualized: Useful Git Commands - DEV Community](https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1))

그러나 문제는 Github에서는 아직까지 UI 상에서 fast forward merge를 지원하지 않고, 명시적인 merge commit을 강제한다.
따라서 Github 상의 Pull request를 fast forward merge 하기 위해서는 아래와 같이 로컬에서 fast-forward merge 후 push하면 Github에서 이를 인지하여 Pull request를 머지 처리한다.

![Image](https://github.com/user-attachments/assets/5acf4ce0-7cfe-44d2-ba59-9b3d65a1d26f)

혹은 Github에서 [Fast Forward PR · Actions · GitHub Marketplace · GitHub](https://github.com/marketplace/actions/fast-forward-pr) 과 같은 github actions를 활용할 수도 있다.

### 참고
- Github에서 지원하는 다른 머지 방식인 squash and merge , rebase and merge는 fast-forward 와 유사한 방식으로 동작하지만 아래와 같은 이유로 적합하지 않다.
	- Squash and merge : 커밋 원자성이 훼손되므로, 이 경우에 적합하지 않다.
	- Rebase and merge : rebase는 결국 commit을 다시 수행하는 과정이라고 볼 수 있는데, 위에서 살펴본 것처럼 수동으로 충돌 해결이 필요하므로 버튼 자체가 disable된다.
- 그리고 사실 이 문제는 Github에서 fast forward merge를 지원하지 않기 때문에 발생하는 문제이고, Gitlab 등에서는 Fast forward merge를 UI 상에서 가능하다.
	- ![Image](https://github.com/user-attachments/assets/514ad420-ecf6-4210-bbad-54312e7729e5)

## 더 좋은 방법 및 결론

결국 여기까지 오면서 느낀 점은 "생각보다 복잡하다"였다. 그리고 결정적으로 복잡함을 이겨내더라도, 온전히 기존 히스토리를 유지할 수 없다는 한계점 또한 있다.
그렇기 때문에 이 글에서 결정적으로 담고 싶은 메시지는 아래와 같다.

1. 코드 복붙은 git 히스토리 관리 입장에서도 바람직하지 않다.
	- 위에서 살펴보았듯이 이후에 수습은 가능하나, 복잡하고, 상황에 따라서는 온전한 수습이 되지 않을 수 있다.
2. 코드 복붙이 불가피하다면, 복사 시점에 단순 내용 복사가 아닌 히스토리를 같이 복사할 수 있는 방법을 활용하는 것이 좋다. ([Git copy file preserving history - Stack Overflow](https://stackoverflow.com/questions/16937359/git-copy-file-preserving-history/44036771#44036771) 참고)

## References

- [Mundane git tricks: Combining two files into one while preserving line history - The Old New Thing](https://devblogs.microsoft.com/oldnewthing/20190514-00/?p=102493)
- [View commit history across file renames and moves - GitHub Changelog](https://github.blog/changelog/2022-06-06-view-commit-history-across-file-renames-and-moves/)
- [Git - git-log Documentation](https://git-scm.com/docs/git-log#Documentation/git-log.txt---follow)
- [git log - \`git log --follow --graph\` skips commits - Stack Overflow](https://stackoverflow.com/questions/46487476/git-log-follow-graph-skips-commits/46492159#46492159)
- [version control - Git log (--follow) not working to show history beyond renames - Stack Overflow](https://stackoverflow.com/questions/64454637/git-log-follow-not-working-to-show-history-beyond-renames/64468571#64468571)
- [Does 'git log' use Depth First Search traversal to display the commits? - Stack Overflow](https://stackoverflow.com/questions/59520900/does-git-log-use-depth-first-search-traversal-to-display-the-commits)
- [How to do a fast-forward merge on GitHub? - Stack Overflow](https://stackoverflow.com/questions/60597400/how-to-do-a-fast-forward-merge-on-github/66906599#66906599)
- [🌳🚀 CS Visualized: Useful Git Commands - DEV Community](https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1)
- [About pull request merges - GitHub Docs](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#rebase-and-merge-your-commits)
- [Fast Forward PR · Actions · GitHub Marketplace · GitHub](https://github.com/marketplace/actions/fast-forward-pr)
- [Merge methods \| GitLab](https://docs.gitlab.com/ee/user/project/merge_requests/methods/#fast-forward-merge)
- [Git copy file preserving history - Stack Overflow](https://stackoverflow.com/questions/16937359/git-copy-file-preserving-history/44036771#44036771)
